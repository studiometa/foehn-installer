<?php

declare(strict_types=1);

namespace Studiometa\FoehnInstaller;

use Composer\IO\IOInterface;

/**
 * Generates the WordPress web root directory structure.
 *
 * Creates:
 * - web/index.php
 * - web/wp-config.php
 * - web/wp-content/themes/{theme-name} → symlink to ../../theme/
 * - web/wp-content/mu-plugins/00-loader.php
 * - web/wp-content/mu-plugins/_custom → symlink to ../../mu-plugins/
 */
final class WebRootGenerator
{
    public function __construct(
        private readonly IOInterface $io,
        private readonly string $projectRoot,
        private readonly InstallerConfig $config,
    ) {}

    /**
     * Generate the complete web root structure.
     */
    public function generate(): void
    {
        $this->io->write('<info>Foehn:</info> Generating web root...');

        $this->createDirectories();
        $this->generateIndexPhp();
        $this->generateWpConfig();
        $this->copyEnvFile();
        $this->symlinkTheme();
        $this->symlinkMuPlugins();
        $this->generateMuPluginLoader();

        $this->io->write('<info>Foehn:</info> Web root generated successfully.');
    }

    /**
     * Create the required directory structure.
     */
    private function createDirectories(): void
    {
        $dirs = [
            $this->webPath(),
            $this->webPath('wp-content'),
            $this->webPath('wp-content/themes'),
            $this->webPath('wp-content/plugins'),
            $this->webPath('wp-content/mu-plugins'),
            $this->webPath('wp-content/uploads'),
        ];

        foreach ($dirs as $dir) {
            if (is_dir($dir)) {
                continue;
            }

            mkdir($dir, 0o755, true);
            $this->io->write("  <comment>Created:</comment> {$this->relativePath($dir)}");
        }
    }

    /**
     * Generate web/index.php.
     */
    private function generateIndexPhp(): void
    {
        $wpDir = $this->config->wpDir;
        $path = $this->webPath('index.php');

        $content = <<<PHP
            <?php

            /**
             * Front controller — auto-generated by foehn-installer.
             * DO NOT EDIT — this file is regenerated on `composer install`.
             */

            define('WP_USE_THEMES', true);
            require __DIR__ . '/{$wpDir}/wp-blog-header.php';

            PHP;

        $this->writeFile($path, $content);
    }

    /**
     * Generate web/wp-config.php.
     */
    private function generateWpConfig(): void
    {
        $path = $this->webPath('wp-config.php');
        $wpDir = $this->config->wpDir;
        $configDir = $this->config->configDir;

        $content = <<<'PHP'
            <?php

            /**
             * WordPress configuration — auto-generated by foehn-installer.
             * DO NOT EDIT — this file is regenerated on `composer install`.
             *
             * Project configuration lives in config/*.config.php files.
             * See: https://github.com/studiometa/foehn-framework
             */

            // Load Composer autoloader
            require_once dirname(__DIR__) . '/vendor/autoload.php';

            PHP;

        // Add config loading if config directory exists
        $configPath = $this->projectRoot . '/' . $configDir;
        if (is_dir($configPath)) {
            $content .= <<<PHP

                // Load project configuration
                \$configDir = dirname(__DIR__) . '/{$configDir}';

                // Load base wordpress config
                if (file_exists(\$configDir . '/wordpress.config.php')) {
                    require_once \$configDir . '/wordpress.config.php';
                }

                // Load environment-specific overrides
                \$env = getenv('WP_ENVIRONMENT_TYPE') ?: 'production';
                \$envConfig = \$configDir . "/wordpress.{\$env}.config.php";
                if (file_exists(\$envConfig)) {
                    require_once \$envConfig;
                }

                PHP;
        }

        $content .= <<<PHP

            // Load .env file (vlucas/phpdotenv is a dependency of studiometa/foehn)
            if (file_exists(dirname(__DIR__) . '/.env')) {
                \$dotenv = Dotenv\\Dotenv::createImmutable(dirname(__DIR__));
                \$dotenv->safeLoad();
            }

            // Environment helpers
            \$env = function (string \$key, mixed \$default = null): mixed {
                \$value = \$_ENV[\$key] ?? \$_SERVER[\$key] ?? getenv(\$key);
                return \$value !== false ? \$value : \$default;
            };

            // Database
            define('DB_NAME', \$env('DB_NAME', 'wordpress'));
            define('DB_USER', \$env('DB_USER', 'root'));
            define('DB_PASSWORD', \$env('DB_PASSWORD', ''));
            define('DB_HOST', \$env('DB_HOST', 'localhost'));
            define('DB_CHARSET', \$env('DB_CHARSET', 'utf8mb4'));
            define('DB_COLLATE', '');

            // URLs
            define('WP_HOME', \$env('WP_HOME', 'http://localhost'));
            define('WP_SITEURL', \$env('WP_SITEURL', WP_HOME . '/{$wpDir}'));

            // Content directory
            define('WP_CONTENT_DIR', __DIR__ . '/wp-content');
            define('WP_CONTENT_URL', WP_HOME . '/wp-content');

            // Salts — load from environment or config
            if (file_exists(dirname(__DIR__) . '/{$configDir}/wordpress-salts.config.php')) {
                require_once dirname(__DIR__) . '/{$configDir}/wordpress-salts.config.php';
            } else {
                // Fallback: generate unique salts from env vars or use defaults
                // In production, use environment variables or config/wordpress-salts.config.php
                \$salts = [
                    'AUTH_KEY', 'SECURE_AUTH_KEY', 'LOGGED_IN_KEY', 'NONCE_KEY',
                    'AUTH_SALT', 'SECURE_AUTH_SALT', 'LOGGED_IN_SALT', 'NONCE_SALT',
                ];
                foreach (\$salts as \$salt) {
                    if (!defined(\$salt)) {
                        define(\$salt, \$env(\$salt, 'change-me-' . \$salt . '-' . md5(__DIR__)));
                    }
                }
            }

            // Table prefix
            \$table_prefix = \$env('DB_PREFIX', 'wp_');

            // Environment
            define('WP_ENVIRONMENT_TYPE', \$env('WP_ENVIRONMENT_TYPE', 'production'));

            // Debug
            \$isDebug = filter_var(\$env('WP_DEBUG', false), FILTER_VALIDATE_BOOLEAN);
            define('WP_DEBUG', \$isDebug);
            define('WP_DEBUG_DISPLAY', \$isDebug && WP_ENVIRONMENT_TYPE !== 'production');
            define('WP_DEBUG_LOG', \$isDebug);
            define('SCRIPT_DEBUG', \$isDebug);

            // Security
            define('DISALLOW_FILE_EDIT', true);
            define('DISALLOW_FILE_MODS', WP_ENVIRONMENT_TYPE === 'production');

            // Performance
            define('WP_POST_REVISIONS', (int) \$env('WP_POST_REVISIONS', 5));

            // ABSPATH
            if (!defined('ABSPATH')) {
                define('ABSPATH', __DIR__ . '/{$wpDir}/');
            }

            require_once ABSPATH . 'wp-settings.php';

            PHP;

        $this->writeFile($path, $content);
    }

    /**
     * Copy .env.example to .env if .env doesn't exist.
     */
    private function copyEnvFile(): void
    {
        $envFile = $this->projectRoot . '/.env';
        $envExample = $this->projectRoot . '/.env.example';

        if (file_exists($envFile)) {
            return;
        }

        if (!file_exists($envExample)) {
            return;
        }

        copy($envExample, $envFile);
        $this->io->write('  <comment>Created:</comment> .env (from .env.example)');
    }

    /**
     * Create theme symlink.
     */
    private function symlinkTheme(): void
    {
        $themeSource = $this->projectRoot . '/' . $this->config->themeDir;
        $themeTarget = $this->webPath('wp-content/themes/' . $this->config->themeName);

        if (!is_dir($themeSource)) {
            $this->io->write("  <warning>Skipped theme symlink:</warning> {$this->config->themeDir}/ not found");

            return;
        }

        $this->createSymlink($themeSource, $themeTarget);
    }

    /**
     * Create mu-plugins symlink.
     */
    private function symlinkMuPlugins(): void
    {
        $muSource = $this->projectRoot . '/' . $this->config->muPluginsDir;
        $muTarget = $this->webPath('wp-content/mu-plugins/_custom');

        if (!is_dir($muSource)) {
            return;
        }

        $this->createSymlink($muSource, $muTarget);
    }

    /**
     * Generate the mu-plugin loader that loads custom mu-plugins.
     */
    private function generateMuPluginLoader(): void
    {
        $muSource = $this->projectRoot . '/' . $this->config->muPluginsDir;

        if (!is_dir($muSource)) {
            return;
        }

        $path = $this->webPath('wp-content/mu-plugins/00-loader.php');

        $content = <<<'PHP'
            <?php

            /**
             * MU-Plugin loader — auto-generated by foehn-installer.
             * DO NOT EDIT — this file is regenerated on `composer install`.
             *
             * Loads all PHP files from the _custom/ symlinked directory.
             */

            $customDir = __DIR__ . '/_custom';

            if (!is_dir($customDir)) {
                return;
            }

            foreach (glob($customDir . '/*.php') as $file) {
                require_once $file;
            }

            PHP;

        $this->writeFile($path, $content);
    }

    /**
     * Create a symlink, replacing existing one if needed.
     */
    private function createSymlink(string $source, string $target): void
    {
        // Remove existing symlink or directory
        if (is_link($target)) {
            unlink($target);
        } elseif (is_dir($target)) {
            $this->io->write(
                "  <warning>Skipped symlink:</warning> {$this->relativePath($target)} already exists as directory",
            );

            return;
        }

        // Create relative symlink
        $relativeSource = $this->makeRelativePath(dirname($target), $source);
        symlink($relativeSource, $target);
        $this->io->write("  <comment>Symlinked:</comment> {$this->relativePath($target)} → {$relativeSource}");
    }

    /**
     * Write a file and report it.
     */
    private function writeFile(string $path, string $content): void
    {
        // Normalize indentation (remove leading spaces from heredoc)
        $content = $this->normalizeIndentation($content);

        $existed = file_exists($path);
        file_put_contents($path, $content);

        $action = $existed ? 'Updated' : 'Created';
        $this->io->write("  <comment>{$action}:</comment> {$this->relativePath($path)}");
    }

    /**
     * Normalize heredoc indentation.
     */
    private function normalizeIndentation(string $content): string
    {
        $lines = explode("\n", $content);
        if (count($lines) < 2) {
            return $content;
        }

        // Find minimum indentation (excluding empty lines and first line)
        $minIndent = PHP_INT_MAX;
        foreach ($lines as $i => $line) {
            if ($i === 0 || trim($line) === '') {
                continue;
            }
            $indent = strlen($line) - strlen(ltrim($line));
            if ($indent < $minIndent) {
                $minIndent = $indent;
            }
        }

        if ($minIndent === 0 || $minIndent === PHP_INT_MAX) {
            return $content;
        }

        // Remove common indentation
        return implode("\n", array_map(static fn(string $line): string => trim($line) === ''
            ? ''
            : substr($line, $minIndent), $lines));
    }

    /**
     * Get a path relative to the web directory.
     */
    private function webPath(string $path = ''): string
    {
        $base = $this->projectRoot . '/' . $this->config->webDir;

        return $path !== '' ? $base . '/' . $path : $base;
    }

    /**
     * Get a path relative to the project root (for display).
     */
    private function relativePath(string $path): string
    {
        return str_replace($this->projectRoot . '/', '', $path);
    }

    /**
     * Make a relative path from one location to another.
     */
    private function makeRelativePath(string $from, string $to): string
    {
        $from = rtrim($from, '/');
        $to = rtrim($to, '/');

        $fromParts = explode('/', $from);
        $toParts = explode('/', $to);

        // Find common prefix
        $common = 0;
        $max = min(count($fromParts), count($toParts));
        while ($common < $max && $fromParts[$common] === $toParts[$common]) {
            $common++;
        }

        // Build relative path
        $ups = count($fromParts) - $common;
        $remaining = array_slice($toParts, $common);

        $parts = array_merge(array_fill(0, $ups, '..'), $remaining);

        return implode('/', $parts);
    }
}
